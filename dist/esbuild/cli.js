#!/usr/bin/env node
"use strict";var D=Object.create;var _=Object.defineProperty;var $=Object.getOwnPropertyDescriptor;var q=Object.getOwnPropertyNames;var L=Object.getPrototypeOf,M=Object.prototype.hasOwnProperty;var H=(i,t,r,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let e of q(t))!M.call(i,e)&&e!==r&&_(i,e,{get:()=>t[e],enumerable:!(s=$(t,e))||s.enumerable});return i};var g=(i,t,r)=>(r=i!=null?D(L(i)):{},H(t||!i||!i.__esModule?_(r,"default",{value:i,enumerable:!0}):r,i));var T=g(require("figlet"));var S={name:"ssv-scanner",version:"1.0.3",description:"Tool for retrieving events data (cluster snapshots and owner nonce) from the SSV network contract.",author:"SSV.Network",repository:"https://github.com/bloxapp/ssv-scanner",license:"MIT",keywords:["ssv","ssv.network","cluster","nonce","scanner"],main:"./dist/tsc/src/main.js",types:"./dist/tsc/src/main.d.ts",bin:{"ssv-keys":"./dist/tsc/src/cli.js"},engines:{node:">=18"},scripts:{"dev:cli":"ts-node src/cli.ts",cli:"node ./dist/tsc/src/cli.js",lint:"eslint src/ --ext .js,.jsx,.ts,.tsx",clean:"rm -rf dist build package","ts-node":"ts-node","copy-json":"cpy './src/shared/abi/*.json' './dist/tsc/src/shared/abi/'",build:"tsc -p tsconfig.json","build-all":"yarn clean && yarn build && yarn copy-json && yarn esbuild",esbuild:"node ./esbuild.js","pre-commit":"yarn test && yarn lint && yarn build-all"},devDependencies:{"@types/argparse":"^2.0.10","@types/cli-progress":"^3.11.0","@types/node":"^15.14.9","cpy-cli":"^5.0.0",esbuild:"^0.14.38","esbuild-node-externals":"^1.4.1",eslint:"^7.32.0","ts-node":"^10.9.1",typescript:"^4.6.4"},dependencies:{"@types/figlet":"^1.5.4",argparse:"^2.0.1","cli-progress":"^3.11.2",figlet:"^1.5.2",web3:"^4.11.1"},licenses:[{MIT:"SEE LICENSE IN LICENCE FILE"}]};var B=g(require("process")),j=require("argparse");var I=require("argparse"),b=class{constructor(t,r){this.name=t;this.description=r;this.env="";this.parser=new I.ArgumentParser({description:this.description}),this.setArguments(this.parser)}parse(t){t.splice(0,1);let r=t.map(e=>(e.endsWith("_stage")&&(this.env="stage",e=e.replace("_stage","")),e)),s=this.parser.parse_args(r);return this.env&&(s.network+=`_${this.env}`),s}};var E=g(require("cli-progress"));var O=g(require("web3")),U={MAINNET:"prod:v4.mainnet",HOLESKY:"prod:v4.holesky",HOLESKY_STAGE:"stage:v4.holesky"},w=class{constructor(t,r){let[s,e]=U[t.toUpperCase()].split(":"),[o,n]=e.split(".");o=o.toUpperCase(),n=n.toUpperCase();let a;try{a=require(`../shared/abi/${s}.${e}.abi.json`)}catch(c){throw console.error(`Failed to load JSON data from ${s}.${e}.abi.json`,c),c}let l;try{l=require(`../shared/abi/${s}.${e}.views.abi.json`)}catch(c){throw console.error(`Failed to load JSON data from ${s}.${e}.views.abi.json`,c),c}if(!a.contractAddress||!a.abi||!a.genesisBlock)throw new Error(`Missing core data in JSON for ${s}.${e}`);if(!l.contractAddress||!l.abi)throw new Error(`Missing views data in JSON for ${s}.${e}`);this.contract={version:o,network:n,address:a.contractAddress,addressViews:l.contractAddress,abi:a.abi,abiViews:l.abi,genesisBlock:a.genesisBlock},this.web3=new O.default(r)}get contractAddress(){return this.contract.address}get abiCore(){return this.contract.abi}get contractCore(){return new this.web3.eth.Contract(this.abiCore,this.contract.address)}get genesisBlock(){return this.contract.genesisBlock}};var V=g(require("web3")),f=class{constructor(t){this.DAY=5400;this.WEEK=this.DAY*7;this.MONTH=this.DAY*30;if(!t.nodeUrl)throw Error("ETH1 node is required");if(!t.network)throw Error("Network is required");if(!t.ownerAddress)throw Error("Cluster owner address is required");if(t.ownerAddress.length!==42)throw Error("Invalid owner address length.");if(!t.ownerAddress.startsWith("0x"))throw Error("Invalid owner address.");this.params=t,this.params.ownerAddress=new V.default().utils.toChecksumAddress(this.params.ownerAddress)}};var v=class extends f{constructor(){super(...arguments);this.eventsList=["ValidatorAdded"]}async run(r){r&&(console.log(`
Scanning blockchain...`),this.progressBar=new E.default.SingleBar({},E.default.Presets.shades_classic));try{let s=await this._getLatestNonce(r);return r&&this.progressBar.stop(),s}catch(s){throw r&&this.progressBar.stop(),new Error(s)}}async _getLatestNonce(r){let s=new w(this.params.network,this.params.nodeUrl),e;try{e=await s.web3.eth.getBlockNumber()}catch{throw new Error("Could not access the provided node endpoint.")}try{await s.contractCore.methods.owner().call()}catch{throw new Error("Could not find any cluster snapshot from the provided contract address.")}let o=this.MONTH,n=0,a=s.genesisBlock,l=s.web3.eth.abi.encodeParameter("address",this.params.ownerAddress),c={fromBlock:a,toBlock:Number(e),topics:[null,l]};r&&this.progressBar.start(Number(e),0);do{let u;try{u=(await s.contractCore.getPastEvents("allEvents",c)).filter(y=>this.eventsList.includes(y.event)),n+=u.length,c.fromBlock=c.toBlock+1}catch(y){if(o===this.MONTH)o=this.WEEK;else if(o===this.WEEK)o=this.DAY;else throw new Error(y)}c.toBlock=Math.min(c.fromBlock+o,Number(e)),r&&this.progressBar.update(c.toBlock)}while(c.toBlock-c.fromBlock>0);return r&&this.progressBar.update(Number(e),Number(e)),n}};var N=class extends b{constructor(){super("nonce","Handles nonce operations")}setArguments(t){t.add_argument("-nw","--network",{help:"The network",choices:["mainnet","holesky"],required:!0,dest:"network"}),t.add_argument("-n","--node-url",{help:"ETH1 (execution client) node endpoint url",required:!0,dest:"nodeUrl"}),t.add_argument("-oa","--owner-address",{help:"The cluster owner address (in the SSV contract)",required:!0,dest:"ownerAddress"})}async run(t){try{let s=await new v(t).run(!0);console.log("Next Nonce:",s)}catch(r){console.error("\x1B[31m",r.message)}}};var x=g(require("cli-progress"));var C=class extends f{constructor(){super(...arguments);this.eventsList=["ClusterDeposited","ClusterWithdrawn","ValidatorRemoved","ValidatorAdded","ClusterLiquidated","ClusterReactivated"]}async run(r,s){if(!(Array.isArray(r)&&this._isValidOperatorIds(r.length)))throw Error("Comma-separated list of operator IDs. The amount must be 3f+1 compatible.");r=[...r].sort((n,a)=>n-a),s&&(console.log(`
Scanning blockchain...`),this.progressBar=new x.default.SingleBar({},x.default.Presets.shades_classic));let o=await this._getClusterSnapshot(r,s);return s&&this.progressBar.stop(),o}async _getClusterSnapshot(r,s){let e,o=new w(this.params.network,this.params.nodeUrl);try{e=await o.web3.eth.getBlockNumber()}catch(p){throw new Error("Could not access the provided node endpoint: "+p)}try{await o.contractCore.methods.owner().call()}catch(p){throw new Error("Could not find any cluster snapshot from the provided contract address: "+p)}let n=this.MONTH,a,l=0,c=0,u=o.genesisBlock,y=o.web3.eth.abi.encodeParameter("address",this.params.ownerAddress),m={fromBlock:Math.max(Number(e)-n,u),toBlock:Number(e),topics:[null,y]};for(s&&this.progressBar.start(Number(e),0);!a&&m.fromBlock>=u;){let p;try{p=await o.contractCore.getPastEvents("allEvents",m),p.filter(d=>this.eventsList.includes(d.event)).filter(d=>JSON.stringify(d.returnValues.operatorIds.map(k=>Number(k)))===JSON.stringify(r)).sort((d,k)=>Number(d.blockNumber)-Number(k.blockNumber)).forEach(d=>{if(d.blockNumber>=l){let k=l;if(l=Number(d.blockNumber),k===d.blockNumber&&d.transactionIndex<c)return;c=d.transactionIndex,a=d.returnValues.cluster}}),m.toBlock=m.fromBlock}catch(d){console.error(d),n===this.MONTH?n=this.WEEK:n===this.WEEK&&(n=this.DAY)}m.fromBlock=m.toBlock-n,s&&this.progressBar.update(Number(e)-(m.toBlock-n))}s&&this.progressBar.update(Number(e),Number(e));let h=a?[a.validatorCount,a.networkFeeIndex,a.index,a.active,a.balance]:["0","0","0",!0,"0"];return{payload:{Owner:this.params.ownerAddress,Operators:r.sort((p,d)=>p-d).join(","),Block:l||Number(e),Data:h.join(",")},cluster:{validatorCount:h[0],networkFeeIndex:h[1],index:h[2],active:h[3],balance:h[4]}}}_isValidOperatorIds(r){return!(r<4||r>13||r%3!=1)}};var A=class extends b{constructor(){super("cluster","Handles cluster operations")}setArguments(t){t.add_argument("-nw","--network",{help:"The network",choices:["mainnet","holesky"],required:!0,dest:"network"}),t.add_argument("-n","--node-url",{help:"ETH1 (execution client) node endpoint url",required:!0,dest:"nodeUrl"}),t.add_argument("-oa","--owner-address",{help:"The cluster owner address (in the SSV contract)",required:!0,dest:"ownerAddress"}),t.add_argument("-oids","--operator-ids",{help:"Comma-separated list of operators IDs regarding the cluster that you want to query",required:!0,dest:"operatorIds"})}async run(t){try{let r=t.operatorIds.split(",").map(o=>{if(Number.isNaN(+o))throw new Error("Operator Id should be the number");return+o}).sort((o,n)=>o-n),e=await new C(t).run(r,!0);console.table(e.payload),console.log("Cluster snapshot:"),console.table(e.cluster),console.log(JSON.stringify({block:e.payload.Block,"cluster snapshot":e.cluster,cluster:Object.values(e.cluster)},(o,n)=>typeof n=="bigint"?n.toString():n,"  "))}catch(r){console.error("\x1B[31m",r.message)}}};var F=async i=>new Promise(t=>{(0,T.default)(i,(r,s)=>{if(r)return t("");t(s)})});async function P(){let i=`SSV Scanner v${S.version}`,t=await F(i);if(t){console.log(" -----------------------------------------------------------------------------------"),console.log(`${t||i}`),console.log(" -----------------------------------------------------------------------------------");for(let u of String(S.description).match(/.{1,75}/g)||[])console.log(` ${u}`);console.log(` -----------------------------------------------------------------------------------
`)}let r=new j.ArgumentParser,s=r.add_subparsers({title:"commands",dest:"command"}),e=new A,o=new N,n=s.add_parser(e.name,{add_help:!0}),a=s.add_parser(o.name,{add_help:!0}),l="",c=B.argv.slice(2);switch(c[1]&&c[1].includes("--help")?(e.setArguments(n),o.setArguments(a),r.parse_args()):(l=r.parse_known_args()[0].command,e.setArguments(n),o.setArguments(a)),l){case e.name:await e.run(e.parse(c));break;case o.name:await o.run(o.parse(c));break;default:console.error("Command not found"),B.exit(1)}}P();
