#!/usr/bin/env node
"use strict";var H=Object.create;var j=Object.defineProperty;var J=Object.getOwnPropertyDescriptor;var W=Object.getOwnPropertyNames;var F=Object.getPrototypeOf,K=Object.prototype.hasOwnProperty;var U=(o,r,e,n)=>{if(r&&typeof r=="object"||typeof r=="function")for(let t of W(r))!K.call(o,t)&&t!==e&&j(o,t,{get:()=>r[t],enumerable:!(n=J(r,t))||n.enumerable});return o};var b=(o,r,e)=>(e=o!=null?H(F(o)):{},U(r||!o||!o.__esModule?j(e,"default",{value:o,enumerable:!0}):e,o));var q=b(require("figlet"));var x={name:"ssv-scanner",version:"1.0.4",description:"Tool for retrieving events data (cluster snapshots and owner nonce) from the SSV network contract.",author:"SSV.Network",repository:"https://github.com/bloxapp/ssv-scanner",license:"MIT",keywords:["ssv","ssv.network","cluster","nonce","scanner"],main:"./dist/tsc/src/main.js",types:"./dist/tsc/src/main.d.ts",bin:{"ssv-keys":"./dist/tsc/src/cli.js"},engines:{node:">=18"},scripts:{"dev:cli":"ts-node src/cli.ts",cli:"node ./dist/tsc/src/cli.js",lint:"eslint src/ --ext .js,.jsx,.ts,.tsx",clean:"rm -rf dist build package","ts-node":"ts-node","copy-json":"cpy './src/shared/abi/*.json' './dist/tsc/src/shared/abi/'",build:"tsc -p tsconfig.json","build-all":"yarn clean && yarn build && yarn copy-json && yarn esbuild",esbuild:"node ./esbuild.js","pre-commit":"yarn test && yarn lint && yarn build-all"},devDependencies:{"@types/argparse":"^2.0.10","@types/cli-progress":"^3.11.0","@types/node":"^15.14.9","cpy-cli":"^5.0.0",esbuild:"^0.14.38","esbuild-node-externals":"^1.4.1",eslint:"^7.32.0","ts-node":"^10.9.1",typescript:"^4.6.4"},dependencies:{"@types/figlet":"^1.5.4",argparse:"^2.0.1","cli-progress":"^3.11.2",ethers:"^6.13.2",figlet:"^1.5.2"},licenses:[{MIT:"SEE LICENSE IN LICENCE FILE"}]};var E=b(require("process")),D=require("argparse");var T=require("argparse"),g=class{constructor(r,e){this.name=r;this.description=e;this.env="";this.parser=new T.ArgumentParser({description:this.description}),this.setArguments(this.parser)}parse(r){r.splice(0,1);let e=r.map(t=>(t.endsWith("_stage")&&(this.env="stage",t=t.replace("_stage","")),t)),n=this.parser.parse_args(e);return this.env&&(n.network+=`_${this.env}`),n}};var B=require("ethers"),_=b(require("cli-progress"));var R={MAINNET:"prod:v4.mainnet",HOLESKY:"prod:v4.holesky",HOLESKY_STAGE:"stage:v4.holesky"},y=o=>{let[r,e]=R[o.toUpperCase()].split(":"),n;try{n=require(`../shared/abi/${r}.${e}.abi.json`)}catch(s){throw console.error(`Failed to load JSON data from ${r}.${e}.abi.json`,s),s}let t;try{t=require(`../shared/abi/${r}.${e}.abi.json`)}catch(s){throw console.error(`Failed to load JSON data from ${r}.${e}.abi.json`,s),s}if(!n.contractAddress||!n.abi||!n.genesisBlock)throw new Error(`Missing core data in JSON for ${r}.${e}`);if(!t.contractAddress||!t.abi)throw new Error(`Missing views data in JSON for ${r}.${e}`);return{contractAddress:t.contractAddress,abi:t.abi,genesisBlock:t.genesisBlock}};var V=require("ethers"),w=class{constructor(r){this.DAY=5400;this.WEEK=this.DAY*7;this.MONTH=this.DAY*30;if(!r.nodeUrl)throw Error("ETH1 node is required");if(!r.network)throw Error("Network is required");if(!r.ownerAddress)throw Error("Cluster owner address is required");if(r.ownerAddress.length!==42)throw Error("Invalid owner address length.");if(!r.ownerAddress.startsWith("0x"))throw Error("Invalid owner address.");this.params=r,this.params.ownerAddress=V.ethers.getAddress(this.params.ownerAddress)}};var k=class extends w{async run(r){r&&(console.log(`
Scanning blockchain...`),this.progressBar=new _.default.SingleBar({},_.default.Presets.shades_classic));try{let e=await this._getValidatorAddedEventCount(r);return r&&this.progressBar.stop(),e}catch(e){throw r&&this.progressBar.stop(),new Error(e)}}async _getValidatorAddedEventCount(r){let{contractAddress:e,abi:n,genesisBlock:t}=y(this.params.network),s=new B.ethers.JsonRpcProvider(this.params.nodeUrl),a=new B.ethers.Contract(e,n,s),p;try{p=await s.getBlockNumber()}catch{throw new Error("Could not access the provided node endpoint.")}try{await a.owner()}catch{throw new Error("Could not find any cluster snapshot from the provided contract address.")}let c=0,i=this.MONTH;r&&this.progressBar.start(Number(p),0);let d=a.filters.ValidatorAdded(this.params.ownerAddress);for(let m=t;m<=p;m+=i)try{let h=Math.min(m+i-1,p);c+=(await a.queryFilter(d,m,h)).length,r&&this.progressBar.update(h)}catch(h){if(i===this.MONTH)i=this.WEEK;else if(i===this.WEEK)i=this.DAY;else throw new Error(h)}return r&&this.progressBar.update(p,p),c}};var A=class extends g{constructor(){super("nonce","Handles nonce operations")}setArguments(r){r.add_argument("-nw","--network",{help:"The network",choices:["mainnet","holesky"],required:!0,dest:"network"}),r.add_argument("-n","--node-url",{help:"ETH1 (execution client) node endpoint url",required:!0,dest:"nodeUrl"}),r.add_argument("-oa","--owner-address",{help:"The cluster owner address (in the SSV contract)",required:!0,dest:"ownerAddress"})}async run(r){try{let n=await new k(r).run(!0);console.log("Next Nonce:",n)}catch(e){console.error("\x1B[31m",e.message)}}};var C=require("ethers"),I=b(require("cli-progress"));var S=class extends w{async run(r,e){if(!(Array.isArray(r)&&this._isValidOperatorIds(r.length)))throw Error("Comma-separated list of operator IDs. The amount must be 3f+1 compatible.");r=[...r].sort((s,a)=>s-a),e&&(console.log(`
Scanning blockchain...`),this.progressBar=new I.default.SingleBar({},I.default.Presets.shades_classic));let t=await this._getClusterSnapshot(r,e);return e&&this.progressBar.stop(),t}async _getClusterSnapshot(r,e){let{contractAddress:n,abi:t,genesisBlock:s}=y(this.params.network);console.log(this.params.ownerAddress);let a,p=new C.ethers.JsonRpcProvider(this.params.nodeUrl);try{a=await p.getBlockNumber()}catch(u){throw new Error("Could not access the provided node endpoint: "+u)}let c=new C.ethers.Contract(n,t,p);try{await c.owner()}catch(u){throw new Error("Could not find any cluster snapshot from the provided contract address: "+u)}let i=this.MONTH,d,m=0,h=0,O=[c.filters.ClusterDeposited(this.params.ownerAddress),c.filters.ClusterWithdrawn(this.params.ownerAddress),c.filters.ValidatorRemoved(this.params.ownerAddress),c.filters.ValidatorAdded(this.params.ownerAddress),c.filters.ClusterLiquidated(this.params.ownerAddress),c.filters.ClusterReactivated(this.params.ownerAddress)];e&&this.progressBar.start(a,0);let $=JSON.stringify(r);for(let u=a;u>s&&!d;u-=i){let M=Math.max(u-i+1,s);try{for(let N of O)(await c.queryFilter(N,M,u)).map(l=>({event:c.interface.parseLog(l),blockNumber:l.blockNumber,transactionIndex:l.transactionIndex})).filter(l=>JSON.stringify(l.event?.args.operatorIds.map(f=>Number(f))!==$)).sort((l,f)=>l.blockNumber-f.blockNumber).forEach(l=>{if(l.blockNumber>=m){let f=m;if(m=l.blockNumber,f===l.blockNumber&&l.transactionIndex<h)return;h=l.transactionIndex,d=l.event.args.cluster}})}catch(N){console.error(N),i===this.MONTH?i=this.WEEK:i===this.WEEK&&(i=this.DAY)}e&&this.progressBar.update(u)}return e&&this.progressBar.update(a,a),d=d||["0","0","0",!0,"0"],{payload:{Owner:this.params.ownerAddress,Operators:r.join(","),Block:m||a,Data:d.join(",")},cluster:{validatorCount:d[0],networkFeeIndex:d[1].toString(),index:d[2].toString(),active:d[3],balance:d[4].toString()}}}_isValidOperatorIds(r){return!(r<4||r>13||r%3!=1)}};var v=class extends g{constructor(){super("cluster","Handles cluster operations")}setArguments(r){r.add_argument("-nw","--network",{help:"The network",choices:["mainnet","holesky"],required:!0,dest:"network"}),r.add_argument("-n","--node-url",{help:"ETH1 (execution client) node endpoint url",required:!0,dest:"nodeUrl"}),r.add_argument("-oa","--owner-address",{help:"The cluster owner address (in the SSV contract)",required:!0,dest:"ownerAddress"}),r.add_argument("-oids","--operator-ids",{help:"Comma-separated list of operators IDs regarding the cluster that you want to query",required:!0,dest:"operatorIds"})}async run(r){try{let e=r.operatorIds.split(",").map(s=>{if(Number.isNaN(+s))throw new Error("Operator Id should be the number");return+s}).sort((s,a)=>s-a),t=await new S(r).run(e,!0);console.table(t.payload),console.log("Cluster snapshot:"),console.table(t.cluster),console.log(JSON.stringify({block:t.payload.Block,"cluster snapshot":t.cluster,cluster:Object.values(t.cluster)},(s,a)=>typeof a=="bigint"?a.toString():a,"  "))}catch(e){console.error("\x1B[31m",e.message)}}};var G=async o=>new Promise(r=>{(0,q.default)(o,(e,n)=>{if(e)return r("");r(n)})});async function P(){let o=`SSV Scanner v${x.version}`,r=await G(o);if(r){console.log(" -----------------------------------------------------------------------------------"),console.log(`${r||o}`),console.log(" -----------------------------------------------------------------------------------");for(let d of String(x.description).match(/.{1,75}/g)||[])console.log(` ${d}`);console.log(` -----------------------------------------------------------------------------------
`)}let e=new D.ArgumentParser,n=e.add_subparsers({title:"commands",dest:"command"}),t=new v,s=new A,a=n.add_parser(t.name,{add_help:!0}),p=n.add_parser(s.name,{add_help:!0}),c="",i=E.argv.slice(2);switch(i[1]&&i[1].includes("--help")?(t.setArguments(a),s.setArguments(p),e.parse_args()):(c=e.parse_known_args()[0].command,t.setArguments(a),s.setArguments(p)),c){case t.name:await t.run(t.parse(i));break;case s.name:await s.run(s.parse(i));break;default:console.error("Command not found"),E.exit(1)}}P();
