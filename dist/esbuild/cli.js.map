{
  "version": 3,
  "sources": ["../../src/cli-shared.ts", "../../src/commands/Command.ts", "../../src/lib/NonceScanner/NonceScanner.ts", "../../src/lib/contract.provider.ts", "../../src/lib/BaseScanner.ts", "../../src/commands/NonceCommand.ts", "../../src/lib/ClusterScanner/ClusterScanner.ts", "../../src/commands/ClusterCommand.ts", "../../src/cli.ts"],
  "sourcesContent": ["import figlet from 'figlet';\nimport pkg from '../package.json';\nimport * as process from 'process';\nimport { ArgumentParser } from 'argparse';\nimport { NonceCommand } from './commands/NonceCommand';\nimport { ClusterCommand } from './commands/ClusterCommand';\n\nconst FigletMessage = async (message: string) => {\n  return new Promise(resolve => {\n    figlet(message, (error: any, output?: string) => {\n      if (error) {\n        return resolve('');\n      }\n      resolve(output);\n    });\n  })\n}\n\nexport default async function main(): Promise<any> {\n  const messageText = `SSV Scanner v${pkg.version}`;\n  const message = await FigletMessage(messageText);\n  if (message) {\n    console.log(' -----------------------------------------------------------------------------------');\n    console.log(`${message || messageText}`);\n    console.log(' -----------------------------------------------------------------------------------');\n    for (const str of String(pkg.description).match(/.{1,75}/g) || []) {\n      console.log(` ${str}`);\n    }\n    console.log(' -----------------------------------------------------------------------------------\\n');\n  }\n\n  const rootParser = new ArgumentParser();\n  const subParsers = rootParser.add_subparsers({ title: 'commands', dest: 'command' });\n\n  const clusterCommand = new ClusterCommand();\n  const nonceCommand = new NonceCommand();\n  const clusterCommandParser = subParsers.add_parser(clusterCommand.name, { add_help: true })\n  const nonceCommandParser = subParsers.add_parser(nonceCommand.name, { add_help: true });\n\n  let command = '';\n  const args = process.argv.slice(2); // Skip node and script name\n\n  if (args[1] && args[1].includes('--help')) {\n    clusterCommand.setArguments(clusterCommandParser);\n    nonceCommand.setArguments(nonceCommandParser);\n    rootParser.parse_args(); // Print help and exit\n  } else {\n    let args = rootParser.parse_known_args();\n    command = args[0]['command'];\n    clusterCommand.setArguments(clusterCommandParser);\n    nonceCommand.setArguments(nonceCommandParser);\n  }\n\n  switch (command) {\n    case clusterCommand.name:\n      await clusterCommand.run(clusterCommand.parse(args));\n      break;\n    case nonceCommand.name:\n      await nonceCommand.run(nonceCommand.parse(args));\n      break;\n    default:\n      console.error('Command not found');\n      process.exit(1);\n  }\n}\n", "import { ArgumentParser } from 'argparse';\n\nexport abstract class Command {\n  protected parser: ArgumentParser;\n  protected env: string = '';\n\n  protected constructor(public name: string, protected description: string) {\n    this.parser = new ArgumentParser({ description: this.description });\n    this.setArguments(this.parser);\n  }\n\n  abstract setArguments(parser: ArgumentParser): void;\n\n  /**\n   * Parse args custom logic\n   * @param args\n   */\n  parse(args: any[]) {\n    // Remove command name itself\n    args.splice(0, 1);\n\n    // Remove stage env from network name\n    const modifiedArgs = args.map((arg: string) => {\n      if (arg.endsWith('_stage')) {\n        this.env = 'stage';\n        arg = arg.replace('_stage', '');\n      }\n      return arg;\n    });\n\n    // Parse args without env and return env back after\n    const parsedArgs = this.parser.parse_args(modifiedArgs);\n    if (this.env) {\n      parsedArgs.network += `_${this.env}`;\n    }\n    return parsedArgs;\n  }\n\n  abstract run(args: any): void;\n}\n", "import { ethers } from 'ethers';\nimport cliProgress from 'cli-progress';\nimport { getContractSettings } from '../contract.provider';\n\nimport { BaseScanner } from '../BaseScanner';\n\nexport class NonceScanner extends BaseScanner {\n  async run(isCli?: boolean): Promise<number> {\n    if (isCli) {\n      console.log('\\nScanning blockchain...');\n      this.progressBar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic);\n    }\n    try {\n      const data = await this._getValidatorAddedEventCount(isCli);\n      isCli && this.progressBar.stop();\n      return data;\n    } catch (e: any) {\n      isCli && this.progressBar.stop();\n      throw new Error(e);\n    }\n  }\n\n  async _getValidatorAddedEventCount(isCli?: boolean): Promise<number> {\n    const { contractAddress, abi, genesisBlock } = getContractSettings(this.params.network)\n    const provider = new ethers.JsonRpcProvider(this.params.nodeUrl);\n    const contract = new ethers.Contract(contractAddress, abi, provider);\n\n    let latestBlockNumber;\n    try {\n      latestBlockNumber = await provider.getBlockNumber();\n    } catch (err) {\n      throw new Error('Could not access the provided node endpoint.');\n    }\n\n    try {\n      await contract.owner();\n    } catch (err) {\n      throw new Error('Could not find any cluster snapshot from the provided contract address.');\n    }\n\n    let totalEventCount = 0;\n    let blockStep = this.MONTH;\n\n    isCli && this.progressBar.start(Number(latestBlockNumber), 0);\n    const filter = contract.filters.ValidatorAdded(this.params.ownerAddress);\n\n    for (let startBlock = genesisBlock; startBlock <= latestBlockNumber; startBlock += blockStep) {\n      try {\n        const endBlock = Math.min(startBlock + blockStep - 1, latestBlockNumber);\n        const logs = await contract.queryFilter(filter, startBlock, endBlock);\n\n        totalEventCount += logs.length;\n        isCli && this.progressBar.update(endBlock);\n      } catch (error: any) {\n        if (blockStep === this.MONTH) {\n          blockStep = this.WEEK;\n        } else if (blockStep === this.WEEK) {\n          blockStep = this.DAY;\n        } else {\n          throw new Error(error);\n        }\n      }\n    }\n\n    isCli && this.progressBar.update(latestBlockNumber, latestBlockNumber);\n    return totalEventCount;\n  }\n}\n", "export const ContractVersion = {\n  MAINNET: 'prod:v4.mainnet',\n  HOLESKY: 'prod:v4.holesky',\n  HOLESKY_STAGE: 'stage:v4.holesky',\n} as const;\n\nconst getContractSettings = (networkAndEnv: string) => {\n  const [contractEnv, contractNetwork] = ContractVersion[networkAndEnv.toUpperCase() as keyof typeof ContractVersion].split(':');\n\n  let jsonCoreData;\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    jsonCoreData = require(`../shared/abi/${contractEnv}.${contractNetwork}.abi.json`);\n  } catch (err) {\n    console.error(`Failed to load JSON data from ${contractEnv}.${contractNetwork}.abi.json`, err);\n    throw err;\n  }\n\n  let jsonViewsData;\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    jsonViewsData = require(`../shared/abi/${contractEnv}.${contractNetwork}.abi.json`);\n  } catch (err) {\n    console.error(`Failed to load JSON data from ${contractEnv}.${contractNetwork}.abi.json`, err);\n    throw err;\n  }\n\n  // Check if required properties exist in jsonData\n  if (\n    !jsonCoreData.contractAddress ||\n    !jsonCoreData.abi ||\n    !jsonCoreData.genesisBlock\n  ) {\n    throw new Error(\n      `Missing core data in JSON for ${contractEnv}.${contractNetwork}`,\n    );\n  }\n\n  // Check if required properties exist in jsonData\n  if (!jsonViewsData.contractAddress || !jsonViewsData.abi) {\n    throw new Error(\n      `Missing views data in JSON for ${contractEnv}.${contractNetwork}`,\n    );\n  }\n\n  return { contractAddress: jsonViewsData.contractAddress, abi: jsonViewsData.abi, genesisBlock: jsonViewsData.genesisBlock };\n}\n\nexport { getContractSettings }\n", "import { ethers } from 'ethers';\nexport interface SSVScannerParams {\n  network: string,\n  nodeUrl: string,\n  ownerAddress: string,\n}\n\nexport abstract class BaseScanner {\n  protected DAY = 5400;\n  protected WEEK = this.DAY * 7;\n  protected MONTH = this.DAY * 30;\n  protected progressBar: any;\n\n  protected params: SSVScannerParams;\n\n  constructor(scannerParams: SSVScannerParams) {\n    if (!scannerParams.nodeUrl) {\n      throw Error('ETH1 node is required');\n    }\n    if (!scannerParams.network) {\n      throw Error('Network is required');\n    }\n    if (!scannerParams.ownerAddress) {\n      throw Error('Cluster owner address is required');\n    }\n    if (scannerParams.ownerAddress.length !== 42) {\n      throw Error('Invalid owner address length.');\n    }\n    if (!scannerParams.ownerAddress.startsWith('0x')) {\n      throw Error('Invalid owner address.');\n    }\n    this.params = scannerParams;\n    // convert to checksum addresses\n    this.params.ownerAddress = ethers.getAddress(this.params.ownerAddress);\n  }\n}\n", "import { ArgumentParser } from 'argparse';\nimport { Command } from './Command';\nimport { NonceScanner } from '../lib/NonceScanner/NonceScanner';\n\nexport class NonceCommand extends Command {\n  constructor() {\n    super('nonce', 'Handles nonce operations');\n  }\n\n  setArguments(parser: ArgumentParser): void {\n    parser.add_argument('-nw', '--network', {\n      help: 'The network',\n      choices: ['mainnet', 'holesky'],\n      required: true,\n      dest: 'network',\n    });\n    parser.add_argument('-n', '--node-url', {\n      help: `ETH1 (execution client) node endpoint url`,\n      required: true,\n      dest: 'nodeUrl'\n    });\n    parser.add_argument('-oa', '--owner-address', {\n      help: \"The cluster owner address (in the SSV contract)\",\n      required: true,\n      dest: 'ownerAddress'\n    });\n  }\n\n  async run(args: any): Promise<void> {\n    try {\n      const nonceScanner = new NonceScanner(args);\n      const result = await nonceScanner.run(true);\n      console.log('Next Nonce:', result);\n    } catch (e: any) {\n      console.error('\\x1b[31m', e.message);\n    }\n  }\n}\n", "import { ethers } from 'ethers';\nimport cliProgress from 'cli-progress';\nimport { getContractSettings } from '../contract.provider';\n\nimport { BaseScanner } from '../BaseScanner';\n\nexport interface IData {\n  payload: any;\n  cluster: any;\n}\n\n// transactionHash: '0x6de9cf4ef292be3b9dc12c8b97772588eb0c7bdcbe1e16fbd1db342bb071c75a',\n//   blockHash: '0xc4ce5279c035b0a99da0571f977af589b1d783651da3774708e892796ce840c0',\n//   blockNumber: 2624456,\n//   removed: false,\n//   address: '0x0d33801785340072C452b994496B19f196b7eE15',\n//   data: '0x000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000002,\n// topics: [\n//   '0x48a3ea0796746043948f6341d17ff8200937b99262a0b48c2663b951ed7114e5',\n//   '0x0000000000000000000000007934278428d237239addb0bab910b639ec758b98'\n// ],\n//   index: 130,\n//   transactionIndex: 53\n\nexport class ClusterScanner extends BaseScanner {\n  async run(operatorIds: number[], isCli?: boolean): Promise<IData> {\n    const validOperatorIds = Array.isArray(operatorIds) && this._isValidOperatorIds(operatorIds.length);\n    if (!validOperatorIds) {\n      throw Error('Comma-separated list of operator IDs. The amount must be 3f+1 compatible.');\n    }\n\n    operatorIds = [...operatorIds].sort((a: number, b: number) => a - b);\n\n    if (isCli) {\n      console.log('\\nScanning blockchain...');\n      this.progressBar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic);\n    }\n    const data: IData = await this._getClusterSnapshot(operatorIds, isCli);\n    isCli && this.progressBar.stop();\n    return data;\n  }\n\n  private async _getClusterSnapshot(operatorIds: number[], isCli?: boolean): Promise<IData> {\n    const { contractAddress, abi, genesisBlock } = getContractSettings(this.params.network);\n    let latestBlockNumber;\n    const provider = new ethers.JsonRpcProvider(this.params.nodeUrl);\n\n    try {\n      latestBlockNumber = await provider.getBlockNumber();\n    } catch (err) {\n      throw new Error('Could not access the provided node endpoint: ' + err);\n    }\n\n    const contract = new ethers.Contract(contractAddress, abi, provider);\n\n    try {\n      await contract.owner();\n    } catch (err) {\n      throw new Error('Could not find any cluster snapshot from the provided contract address: ' + err);\n    }\n\n    let step = this.MONTH;\n    let clusterSnapshot;\n    let biggestBlockNumber = 0;\n\n    const eventsList = ['ClusterDeposited', 'ClusterWithdrawn', 'ClusterReactivated', 'ValidatorRemoved', 'ValidatorAdded', 'ClusterLiquidated', 'ClusterWithdrawn'];\n\n    isCli && this.progressBar.start(latestBlockNumber, genesisBlock);\n\n    const operatorIdsAsString = JSON.stringify(operatorIds);\n    let prevProgressBarState = genesisBlock;\n    for (let startBlock = latestBlockNumber; startBlock > genesisBlock && !clusterSnapshot; startBlock -= step) {\n      const endBlock = Math.max(startBlock - step + 1, genesisBlock)\n      try {\n        const filter = {\n          address: contractAddress,\n          fromBlock: endBlock,\n          toBlock: startBlock,\n          topics: [null, ethers.zeroPadValue(this.params.ownerAddress, 32)],\n        };\n        const logs = await provider.getLogs(filter);\n\n        let res = logs\n          .map((log: ethers.Log) => ({\n            event: contract.interface.parseLog(log),\n            blockNumber: log.blockNumber,\n            transactionIndex: log.transactionIndex,\n            logIndex: log.index\n          }));\n\n        res = res\n          .filter((parsedLog) => parsedLog.event && eventsList.includes(parsedLog.event.name))\n          .filter((parsedLog) =>\n            JSON.stringify((parsedLog.event?.args.operatorIds.map((bigIntOpId: bigint) => Number(bigIntOpId)))) === operatorIdsAsString\n          )\n          .sort((a, b) => {\n            if (b.blockNumber === a.blockNumber) {\n              if (b.transactionIndex === a.transactionIndex) {\n                return b.logIndex - a.logIndex;\n              } else {\n                return b.transactionIndex - a.transactionIndex\n              }\n            } else {\n              return b.blockNumber - a.blockNumber;\n            }\n          });\n        clusterSnapshot = res[0].event?.args.cluster;\n      } catch (e) {\n        if (step === this.MONTH) {\n          step = this.WEEK;\n          startBlock += this.WEEK;\n        } else if (step === this.WEEK) {\n          step = this.DAY;\n          startBlock += this.DAY;        }\n      }\n      prevProgressBarState += step;\n      isCli && this.progressBar.update(prevProgressBarState, latestBlockNumber);\n    }\n\n    isCli && this.progressBar.update(latestBlockNumber, latestBlockNumber);\n    clusterSnapshot = clusterSnapshot || ['0', '0', '0', true, '0'];\n    return {\n      payload: {\n        'Owner': this.params.ownerAddress,\n        'Operators': operatorIds.join(','),\n        'Block': biggestBlockNumber || latestBlockNumber,\n        'Data': clusterSnapshot.join(',')\n      },\n      cluster: {\n        validatorCount: Number(clusterSnapshot[0]),\n        networkFeeIndex: clusterSnapshot[1].toString(),\n        index: clusterSnapshot[2].toString(),\n        active: clusterSnapshot[3],\n        balance: clusterSnapshot[4].toString()\n      }\n    };\n  }\n\n  private _isValidOperatorIds(operatorsLength: number) {\n    return !(operatorsLength < 4 || operatorsLength > 13 || operatorsLength % 3 != 1);\n  }\n}\n", "import { ArgumentParser } from 'argparse';\nimport { Command } from './Command';\nimport { ClusterScanner } from '../lib/ClusterScanner/ClusterScanner';\n\nexport class ClusterCommand extends Command {\n  constructor() {\n    super('cluster', 'Handles cluster operations');\n  }\n\n  setArguments(parser: ArgumentParser): void {\n    parser.add_argument('-nw', '--network', {\n      help: 'The network',\n      choices: ['mainnet', 'holesky'],\n      required: true,\n      dest: 'network',\n    });\n    parser.add_argument('-n', '--node-url', {\n      help: `ETH1 (execution client) node endpoint url`,\n      required: true,\n      dest: 'nodeUrl'\n    });\n    parser.add_argument('-oa', '--owner-address', {\n      help: \"The cluster owner address (in the SSV contract)\",\n      required: true,\n      dest: 'ownerAddress'\n    });\n    parser.add_argument('-oids', '--operator-ids', {\n      help: `Comma-separated list of operators IDs regarding the cluster that you want to query`,\n      required: true,\n      dest: 'operatorIds'\n    });\n  }\n\n  async run(args: any): Promise<void> {\n    try {\n      const operatorIds = args.operatorIds.split(',')\n        .map((value: any) => {\n          if (Number.isNaN(+value)) throw new Error('Operator Id should be the number');\n          return +value;\n        })\n        .sort((a: number, b: number) => a - b);\n      const clusterScanner = new ClusterScanner(args);\n      const result = await clusterScanner.run(operatorIds, true);\n      console.table(result.payload);\n      console.log('Cluster snapshot:');\n      console.table(result.cluster);\n      console.log(JSON.stringify({\n        'block': result.payload.Block,\n        'cluster snapshot': result.cluster,\n        'cluster': Object.values(result.cluster)\n      }, (_, v) => typeof v === 'bigint' ? v.toString() : v, '  '));\n    } catch (e: any) {\n      console.error('\\x1b[31m', e.message);\n    }\n  }\n}\n", "#!/usr/bin/env node\n'use strict';\nimport main from './cli-shared';\n\nvoid main();\n"],
  "mappings": "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",
  "names": ["import_figlet", "process", "import_argparse", "import_argparse", "Command", "name", "description", "args", "modifiedArgs", "arg", "parsedArgs", "import_ethers", "import_cli_progress", "ContractVersion", "getContractSettings", "networkAndEnv", "contractEnv", "contractNetwork", "jsonCoreData", "err", "jsonViewsData", "import_ethers", "BaseScanner", "scannerParams", "NonceScanner", "BaseScanner", "isCli", "cliProgress", "data", "e", "contractAddress", "abi", "genesisBlock", "getContractSettings", "provider", "contract", "latestBlockNumber", "totalEventCount", "blockStep", "filter", "startBlock", "endBlock", "error", "NonceCommand", "Command", "parser", "args", "result", "NonceScanner", "e", "import_ethers", "import_cli_progress", "ClusterScanner", "BaseScanner", "operatorIds", "isCli", "a", "b", "cliProgress", "data", "contractAddress", "abi", "genesisBlock", "getContractSettings", "latestBlockNumber", "provider", "err", "contract", "step", "clusterSnapshot", "biggestBlockNumber", "eventsList", "operatorIdsAsString", "prevProgressBarState", "startBlock", "endBlock", "filter", "res", "log", "parsedLog", "bigIntOpId", "operatorsLength", "ClusterCommand", "Command", "parser", "args", "operatorIds", "value", "a", "b", "result", "ClusterScanner", "_", "v", "e", "FigletMessage", "message", "resolve", "figlet", "error", "output", "main", "messageText", "package_default", "str", "rootParser", "subParsers", "clusterCommand", "ClusterCommand", "nonceCommand", "NonceCommand", "clusterCommandParser", "nonceCommandParser", "command", "args", "main"]
}
